#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jul  9 16:24:37 2019

@author: pengdandan
"""
import math
import numpy as np


def create_individual():
    individual = []
    for i in keys:
        individual.append(round(random() * frags_count[i]))   
    return individual

def initial_population(popSize):
    population = np.zeros(shape = (popSize,len(keys)),dtype = int)   
    for i in range(popSize):
       population[i] = create_individual(keys, frags_count)       
    return population

def get_cuckoos(nest, best, Lb, Ub):
    beta = 1.5
    sigma_u = (math.gamma(1 + beta) * math.sin(math.pi * beta / 2) / (
                math.gamma((1 + beta) / 2) * beta * (2 ** ((beta - 1) / 2)))) ** (1 / beta)
    sigma_v = 1
    for i in range(len(nest)):
        s = nest[i]
        u = np.random.normal(0, sigma_u, 1)
        v = np.random.normal(0, sigma_v, 1)
        step = u / ((abs(v)) ** (1 / beta))
        stepsize = 0.01 * step * (s - best)   
        s = s + stepsize * np.random.randn(len(s))  
        nest[i] = simpleBounds(s, Lb, Ub)
    return nest

def simple_bounds(s, Lb, Ub):
    for i in range(len(s)):
        if s[i] < Lb[i]:
            s[i] = Lb[i]
        if s[i] > Ub[i]:
            s[i] = Ub[i]
    return s

def get_best_nest(nest, newnest, fitness):
    for j in range(len(nest)):
        fnew = energy(newnest[j])
        if fnew <= fitness[j]:
            fitness[j] = fnew
            nest[j] = newnest[j]
    fmax = max(fitness.values())     
    bestnest =  max(fitness,key = fitness.get)
    return fmax, bestnest, nest, fitness

def empty_nests(nest, Lb, Ub, pa):
    n = len(nest)
    nest1 = nest.copy()
    nest2 = nest.copy()
    rand_m = pa - np.random.rand(n, nest.shape[1])
    rand_m = np.heaviside(rand_m, 0)
    np.random.shuffle(nest1)
    np.random.shuffle(nest2)
    stepsize = np.random.rand(1,1) * (nest1 - nest2)
    new_nest = nest + stepsize * rand_m
    for i in range(len(new_nest)):
        new_nest[i] = simple_bounds(new_nest[i], Lb, Ub)
    return new_nest

## Calculate fitness
def compare_aa(individual):
    aligner = Align.PairwiseAligner()
    aligner.open_gap_score = -10
    aligner.extend_gap_score = -0.5
    aligner.substitution_matrix = blosum62
    
    sel_frag = dict(zip(keys, individual))
    sel_frag_seq = {}
    for i in keys:
        if sel_frag[i] < frags_count[i]:
            sel_frag_seq[i] = frag.select(i, sel_frag[i])      
    
    score = 0  

    for edge in G.edges:
        if sel_frag[edge[0]] < frags_count[edge[0]] and sel_frag[edge[1]] < frags_count[edge[1]]:
             for pos in G.edges[edge]['sameAA']:
                u_aa = sel_frag_seq[edge[0]][pos[0]]
                v_aa = sel_frag_seq[edge[1]][pos[1]]
                score += aligner.score(u_aa, v_aa)
    return score/len(keys)

# Penalty term
def term_count(individual):
    sel_frag = dict(zip(keys, individual))    
    is_null = [sel_frag[i] < frags_count[i] for i in keys]
    return np.sum(is_null)/len(keys)

# Fitness function
def energy(individual):
    return compare_aa(individual) - term_count(individual) 


def cuckoo_search_new(n, pa):
    # Random initial solutions
    nest = initial_population(100)

    # Get the current best
    fitness = {}
    for i in range(len(pop)):
        fitness[i] = energy(pop[i])
    fmax, bestnest, nest, fitness = get_best_nest(pop, pop, fitness)

    # Starting iterations
    for i in range(50):
        # Generate new solutions (but keep the current best)
        nest_c = nest.copy()
        new_nest = get_cuckoos(nest, bestnest, Lb, Ub)
        fnew, bestnest, nest, fitness = get_best_nest(nest, new_nest, fitness)
        # Discovery and randomization
        new_nest = empty_nests(nest, Lb, Ub, pa)
    
        # Evaluate this solution
        fnew, bestnest, nest, fitness = get_best_nest(nest, new_nest, fitness)
        
    


